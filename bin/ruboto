#!/usr/bin/env ruby

begin
  require 'jruby'
  JRuby.objectspace = true
rescue LoadError
end

require 'rubygems'
require 'main'
require 'fileutils'
require 'rexml/document'
require 'jruby-jars'

# fix main (to an extent)
module Main
  class Program
    module InstanceMethods
      def setup_finalizers
        @finalizers ||= []
        ObjectSpace.define_finalizer(self) do
          while((f = @finalizers.pop)); f.call; end
        end
      end
    end
  end
end

$assets = File.expand_path(__FILE__ + "/../../assets")

class AssetCopier
  def initialize(from, to)
    @from = from
    @to = to
  end

  def copy(from, to='')
    FileUtils.mkdir_p(File.join(@to, to))
    FileUtils.cp_r(Dir[File.join(@from, from)], File.join(@to, to))
  end

  def copy_from_absolute_path(from, to='')
    FileUtils.mkdir_p(File.join(@to, to))
    FileUtils.cp_r(Dir[from], File.join(@to, to))
  end
end

###########################################################################
#
# log_action: put text to stdout around the execution of a block
#

def log_action(initial_text, final_text="Done.", &block)
  $stdout.sync = true
  print initial_text, "..."
  yield
  puts final_text
end

###########################################################################
#
# reconfigure_jruby_libs:
#   - removes unneeded code from jruby-core
#   - moves ruby stdlib to the root of the ruby-stdlib jar
#

def reconfigure_jruby_libs
  jruby_core = JRubyJars::core_jar_path.split('/')[-1]
  log_action("Removing unneeded classes from #{jruby_core}") do
    Dir.mkdir "libs/tmp"
    Dir.chdir "libs/tmp"
    FileUtils.move "../#{jruby_core}", "."
    `jar -xf #{jruby_core}`
    File.delete jruby_core
    ['jni', 'org/jruby/ant', 'org/jruby/compiler/ir', 'org/jruby/demo', 'org/jruby/embed/bsf', 
     'org/jruby/embed/jsr223', 'org/jruby/ext/ffi','org/jruby/javasupport/bsf'
    ].each {|i| FileUtils.remove_dir i, true}
    `jar -cf ../#{jruby_core} .`
    Dir.chdir "../.."
    FileUtils.remove_dir "libs/tmp", true
  end

  jruby_stdlib = JRubyJars::stdlib_jar_path.split('/')[-1]
  log_action("Reformatting #{jruby_stdlib}") do
    Dir.mkdir "libs/tmp"
    Dir.chdir "libs/tmp"
    FileUtils.move "../#{jruby_stdlib}", "."
    `jar -xf #{jruby_stdlib}`
    File.delete jruby_stdlib
    FileUtils.move "META-INF/jruby.home/lib/ruby/1.8", ".."
    Dir.chdir "../1.8"
    FileUtils.remove_dir "../tmp", true
    `jar -cf ../#{jruby_stdlib} .`
    Dir.chdir "../.."
    FileUtils.remove_dir "libs/1.8", true
  end
end

def generate_inheriting_file(klass, name, package, script_name, dest='.')
  to = File.join(dest, "src/#{package.gsub('.', '/')}")

  FileUtils.cp(File.expand_path(__FILE__ + "/../../assets/src/Inheriting#{klass}.java"), to)
  FileUtils.move(File.join(to, "Inheriting#{klass}.java"), File.join(to, "#{name}.java"))

  file = File.join(to, "#{name}.java")
  text = File.read(file)
  File.open(file, 'w') do |f|
    f << text.gsub("THE_PACKAGE", package).gsub("Inheriting#{klass}", name).gsub("start.rb", script_name)
  end

  sample_source = File.read(File.join($assets, "samples/sample_#{underscore klass}.rb"))
  File.open File.join(dest, "assets/scripts/#{script_name}"), "a" do |f|
    f << sample_source
  end
end

# active_support/inflector.rb
def underscore(camel_cased_word)
  camel_cased_word.to_s.gsub(/::/, '/').
    gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
    gsub(/([a-z\d])([A-Z])/,'\1_\2').
    tr("-", "_").
    downcase
end



Main {
  mode "gen" do
    mode "app" do
      option("name"){
        required
        argument :required
        description "Name of your app"
      }
      option("target") {
        required
        argument :required
        defaults 'android-8'
        description "android version to target. must begin with 'android-'. Currently must be 'android-8'"
      }
      option("path"){
        required
        argument :required
        description "path to where you want your app."
      }
      option("package"){
        required
        argument :required
        defaults 'org.ruboto.example'
        description "Name of package. Must be unique for every app. A common pattern is yourtld.yourdomain.appname (Ex. org.ruboto.irb)"
      }
      option("activity"){
        required
        argument :required
        defaults 'Main'
        description "name of your primary Activity"
      }

      def run
        path = params['path'].value
        name = params['name'].value
        target = params['target'].value
        package = params['package'].value
        activity = params['activity'].value

        abort "path must be to a directory that does not yet exist. it will be created" if
          File.exists?(path)

        abort "Currently you must set target to 'android-8' (Froyo) for ruboto to work" unless
          target == 'android-8'

        root = File.expand_path(path)
        print "\nGenerating Android app #{name} in #{root}..."
        `android create project -n #{name} -t #{target} -p #{path} -k #{package} -a #{activity}`
        puts "Done"

        puts "\nCopying files:"
        copier = AssetCopier.new $assets, root

        %w{Rakefile .gitignore assets}.each do |f|
          print "#{f}..."
          copier.copy f
          puts "Done"
        end

        print "JRuby jars..."
        copier.copy_from_absolute_path JRubyJars::core_jar_path, "libs"
        copier.copy_from_absolute_path JRubyJars::stdlib_jar_path, "libs"
        puts "Done"

        print "Ruboto java classes..."
        copier.copy "src/org/ruboto/*.java", "src/org/ruboto"
        puts "Done\n\n"

        current_dir = Dir.pwd
        Dir.chdir params['path'].value
        reconfigure_jruby_libs
        Dir.chdir current_dir

        print "\nAdding RubotoActivity and RubotoDialog to the manifest..."
        file = File.join(root, "AndroidManifest.xml")
        text = File.read(file)
        File.open(file, 'w') do |f|
          f << text.gsub("</application>", 
                 %Q{
        <activity android:name="org.ruboto.RubotoActivity">
        </activity>
        <activity android:name="org.ruboto.RubotoDialog" android:theme="@android:style/Theme.Dialog">
        </activity>
    </application>
                  })
        end
        puts "Done"

        print "Setting the package name in ruboto.rb..."
        java_files = [File.join(root, "assets/scripts/ruboto.rb")]
        java_files.each do |file|
          text = File.read(file)
          File.open(file, 'w') do |f|
            f << text.gsub("THE_PACKAGE", package).gsub("ACTIVITY_NAME", activity)
          end
        end
        puts "Done"

        print "Generating the default Activity and script..."
        generate_inheriting_file "Activity", activity, package, "#{underscore(activity)}.rb", path
        puts "Done"

        puts "\nHello, #{name}\n"
      end
    end

    mode "class" do
      argument("class"){
        required
        description "the Android Class that you want."
      }

      option("script_name"){
        argument :required
        description "name of the ruby script in assets/scripts/ that this class will execute. should end in .rb. optional"
      }

      option("name"){
        required
        argument :required
        description "name of the class (and file). Should be CamelCase"
      }


      def run
        abort "cannot find your AndroidManifest.xml to extract info from it. Make sure you're in the root directory of your app" unless
          File.exists? 'AndroidManifest.xml'

        package = REXML::Document.new(File.read('AndroidManifest.xml')).root.attribute('package').value
        name = params['name'].value
        script_name = params['script_name'].value || "#{underscore(name)}.rb"
        klass = params['class'].value

        generate_inheriting_file klass, name, package, script_name
      end
    end

    mode "key" do
      option("keystore"){
        default "~/.android/production.keystore"
        description "path to where the keystore will be saved. defaults to ~/.android/production.keystore"
      }

      option("alias"){
        required
        description "The 'alias' for the key. Identifies the key within the keystore. Required"
      }

      def run
        keystore = params['keystore'].value
        key_alias = params['alias'].value

        `keytool -genkey -keyalg rsa -keysize 4096 -validity 1000000 -keystore #{keystore} -alias #{key_alias}`
      end
    end
  end

  mode "update-jruby" do
    option("force"){
      description "force and update even if the version hasn't changed"
    }

    def run
      jruby_core = Dir.glob("libs/jruby-core-*.jar")[0]
      jruby_stdlib = Dir.glob("libs/jruby-stdlib-*.jar")[0]
      abort "cannot find existing jruby jars in libs. Make sure you're in the root directory of your app" if 
		(not jruby_core or not jruby_stdlib) and not params['force'].value

      current_jruby_version = jruby_core ? jruby_core[16..-5] : "None"
      new_jruby_version = JRubyJars::core_jar_path.split('/')[-1][11..-5]
      abort "both jruby versions are #{new_jruby_version}. Nothing to update. Make sure you 'gem update jruby-jars' if there is a new version" if
		current_jruby_version == new_jruby_version and not params['force'].value
      puts "Current jruby version: #{current_jruby_version}"
      puts "New jruby version: #{new_jruby_version}"

      copier = AssetCopier.new $assets, File.expand_path(".")
      log_action("Removing #{jruby_core}") {`rm #{jruby_core}`} if jruby_core
      log_action("Removing #{jruby_stdlib}") {`rm #{jruby_stdlib}`} if jruby_stdlib
      log_action("Copying #{JRubyJars::core_jar_path} to libs") {copier.copy_from_absolute_path JRubyJars::core_jar_path, "libs"}
      log_action("Copying #{JRubyJars::stdlib_jar_path} to libs") {copier.copy_from_absolute_path JRubyJars::stdlib_jar_path, "libs"}

      reconfigure_jruby_libs

      puts "JRuby version is now: #{new_jruby_version}"
    end
  end

  # just running `ruboto`
  def run
    puts %Q{
      Ruboto -- Ruby for Android
      Execute `ruboto gen app --help` for instructions on how to generate a fresh Ruby-enabled Android app
      Execute `ruboto --help` for other options
    }
  end
}

